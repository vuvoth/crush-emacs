{"version":3,"sources":["../src/span.js"],"names":[],"mappings":";;;;;;;;;;AAAA;;IAAY,I;;;;;;;;AAEZ;;;;;;IAMqB,I;;;;;;;;;AAEjB;AACA;AACA;;AAEA;;;;;kCAKU;;AAQN,mBAAO,KAAK,QAAL,EAAP;AAPA;AAQH;;AAGD;;;;;;;;iCAKS;;AAQL,mBAAO,KAAK,OAAL,EAAP;AAPA;AAQH;;AAED;;;;;;;;yCAKiB,I,EAAM;;AAWnB,iBAAK,iBAAL,CAAuB,IAAvB;AAVA;;AAWA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;uCAoBe,G,EAAK,K,EAAO;;AAQvB,iBAAK,eAAL,CAAqB,GAArB,EAA0B,KAA1B;AAPA;;AAQA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;;;uCASe,G,EAAK;;AAQhB,mBAAO,KAAK,eAAL,CAAqB,GAArB,CAAP;AAPA;AAQH;;AAED;;;;;;;;;+BAMO,G,EAAK,K,EAAO;;AAWf;AACA,iBAAK,QAAL,qBAAiB,GAAjB,EAAwB,KAAxB;AAXA;;AAYA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;gCAgBQ,W,EAAa;;AAWjB,iBAAK,QAAL,CAAc,WAAd;AAVA;;AAWA,mBAAO,IAAP;AACH;;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4BA2BI,a,EAAe,S,EAAW;;AAgB1B,iBAAK,IAAL,CAAU,aAAV,EAAyB,SAAzB;AAfA;;AAgBA,mBAAO,IAAP;AACH;;AAED;;;;;;iCAGS,S,EAAW,O,EAAS;;AAczB,mBAAO,KAAK,IAAL,CAAU;AACb,uBAAU,SADG;AAEb,yBAAU;AAFG,aAAV,CAAP;AAbA;AAiBH;;AAED;;;;;;;;;;;;;;;;+BAaO,U,EAAY;;AAWf,iBAAK,OAAL,CAAa,UAAb;;AAEA;AACA;;AAbA;AAcH;;AAGD;AACA;AACA;;AAEA;;;;mCACW;AACP,mBAAO,KAAK,WAAZ;AACH;;AAED;AACA;AACA;AACA;AACA;;;;kCACU;AACN,mBAAO,KAAK,MAAZ;AACH;;AAED;;;;0CACkB,I,EAAM,CACvB;;AAED;;;;wCACgB,G,EAAK,K,EAAO,CAC3B;;AAED;;;;wCACgB,G,EAAK,CACpB;;AAED;AACA;AACA;AACA;;;;iCACS,a,EAAe,CACvB;;AAED;;;;6BACK,a,EAAe,S,EAAW,CAC9B;;AAED;AACA;AACA;;;;gCACQ,U,EAAY,CACnB;;;;;;kBAtTgB,I","file":"span.js","sourcesContent":["import * as noop from './noop';\n\n/**\n * Span represents a logical unit of work as part of a broader Trace. Examples\n * of span might include remote procedure calls or a in-process function calls\n * to sub-components. A Trace has a single, top-level \"root\" Span that in turn\n * may have zero or more child Spans, which in turn may have children.\n */\nexport default class Span {\n\n    // ---------------------------------------------------------------------- //\n    // OpenTracing API methods\n    // ---------------------------------------------------------------------- //\n\n    /**\n     * Returns the SpanContext object associated with this Span.\n     *\n     * @return {SpanContext}\n     */\n    context() {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 0) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        return this._context();\n    }\n\n\n    /**\n     * Returns the Tracer object used to create this Span.\n     *\n     * @return {Tracer}\n     */\n    tracer() {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 0) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        return this._tracer();\n    }\n\n    /**\n     * Sets the string name for the logical operation this span represents.\n     *\n     * @param {string} name\n     */\n    setOperationName(name) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof name !== 'string' || name.length === 0) {\n                throw new Error('Name must be a string of length > 0');\n            }\n        }\n\n        this._setOperationName(name);\n        return this;\n    }\n\n    /**\n     * Sets a key:value pair on this Span that also propagates to future\n     * children of the associated Span.\n     *\n     * setBaggageItem() enables powerful functionality given a full-stack\n     * opentracing integration (e.g., arbitrary application data from a web\n     * client can make it, transparently, all the way into the depths of a\n     * storage system), and with it some powerful costs: use this feature with\n     * care.\n     *\n     * IMPORTANT NOTE #1: setBaggageItem() will only propagate baggage items to\n     * *future* causal descendants of the associated Span.\n     *\n     * IMPORTANT NOTE #2: Use this thoughtfully and with care. Every key and\n     * value is copied into every local *and remote* child of the associated\n     * Span, and that can add up to a lot of network and cpu overhead.\n     *\n     * @param {string} key\n     * @param {string} value\n     */\n    setBaggageItem(key, value) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        this._setBaggageItem(key, value);\n        return this;\n    }\n\n    /**\n     * Returns the value for a baggage item given its key.\n     *\n     * @param  {string} key\n     *         The key for the given trace attribute.\n     * @return {string}\n     *         String value for the given key, or undefined if the key does not\n     *         correspond to a set trace attribute.\n     */\n    getBaggageItem(key) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n        }\n\n        return this._getBaggageItem(key);\n    }\n\n    /**\n     * Adds a single tag to the span.  See `addTags()` for details.\n     *\n     * @param {string} key\n     * @param {any} value\n     */\n    setTag(key, value) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 2) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof key !== 'string') {\n                throw new Error('Tag key must be a string');\n            }\n        }\n\n        // NOTE: the call is normalized to a call to _addTags()\n        this._addTags({ [key] : value });\n        return this;\n    }\n\n    /**\n     * Adds the given key value pairs to the set of span tags.\n     *\n     * Multiple calls to addTags() results in the tags being the superset of\n     * all calls.\n     *\n     * The behavior of setting the same key multiple times on the same span\n     * is undefined.\n     *\n     * The supported type of the values is implementation-dependent.\n     * Implementations are expected to safely handle all types of values but\n     * may choose to ignore unrecognized / unhandle-able values (e.g. objects\n     * with cyclic references, function objects).\n     *\n     * @return {[type]} [description]\n     */\n    addTags(keyValueMap) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length !== 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof keyValueMap !== 'object') {\n                throw new Error('Invalid argument type');\n            }\n        }\n\n        this._addTags(keyValueMap);\n        return this;\n    }\n\n    /**\n     * Add a log record to this Span, optionally at a user-provided timestamp.\n     *\n     * For example:\n     *\n     *     span.log({\n     *         size: rpc.size(),  // numeric value\n     *         URI: rpc.URI(),  // string value\n     *         payload: rpc.payload(),  // Object value\n     *         \"keys can be arbitrary strings\": rpc.foo(),\n     *     });\n     *\n     *     span.log({\n     *         \"error.description\": error.description(),  // numeric value\n     *     }, error.timestampMillis());\n     *\n     * @param {object} keyValuePairs\n     *        An object mapping string keys to arbitrary value types. All\n     *        Tracer implementations should support bool, string, and numeric\n     *        value types, and some may also support Object values.\n     * @param {number} timestamp\n     *        An optional parameter specifying the timestamp in milliseconds\n     *        since the Unix epoch. Fractional values are allowed so that\n     *        timestamps with sub-millisecond accuracy can be represented. If\n     *        not specified, the implementation is expected to use its notion\n     *        of the current time of the call.\n     */\n    log(keyValuePairs, timestamp) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 2 || arguments.length === 0) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (arguments.length === 2) {\n                if (typeof timestamp !== 'number') {\n                    throw new Error('Expected timestamp to be a number');\n                }\n            }\n            if (typeof keyValuePairs !== 'object') {\n                throw new Error('Expected keyValuePairs to be an object');\n            }\n        }\n\n        this._log(keyValuePairs, timestamp);\n        return this;\n    }\n\n    /**\n     * DEPRECATED\n     */\n    logEvent(eventName, payload) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 2 || arguments.length < 1) {\n                throw new Error('Invalid number of arguments');\n            }\n            if (typeof eventName !== 'string') {\n                throw new Error('Expected eventName to be a string');\n            }\n            if (payload !== undefined && typeof payload !== 'object') {\n                throw new Error('Expected payload to be an object');\n            }\n        }\n\n        return this._log({\n            event   : eventName,\n            payload : payload,\n        });\n    }\n\n    /**\n     * Sets the end timestamp and finalizes Span state.\n     *\n     * With the exception of calls to Span.context() (which are always allowed),\n     * finish() must be the last call made to any span instance, and to do\n     * otherwise leads to undefined behavior.\n     *\n     * @param  {number} finishTime\n     *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n     *         values are supported for timestamps with sub-millisecond accuracy.\n     *         If not specified, the current time (as defined by the\n     *         implementation) will be used.\n     */\n    finish(finishTime) {\n        // Debug-only runtime checks on the arguments\n        if (process.env.NODE_ENV === 'debug') {\n            if (arguments.length > 1) {\n                throw new Error('Invalid arguments');\n            }\n            if (arguments.length === 1 && typeof finishTime !== 'number') {\n                throw new Error('Unexpected argument type');\n            }\n        }\n\n        this._finish(finishTime);\n\n        // Do not return `this`. The Span generally should not be used after it\n        // is finished so chaining is not desired in this context.\n    }\n\n\n    // ---------------------------------------------------------------------- //\n    // Derived classes can choose to implement the below\n    // ---------------------------------------------------------------------- //\n\n    // By default returns a no-op SpanContext.\n    _context() {\n        return noop.spanContext;\n    }\n\n    // By default returns a no-op tracer.\n    //\n    // The base class could store the tracer that created it, but it does not\n    // in order to ensure the no-op span implementation has zero members,\n    // which allows V8 to aggressively optimize calls to such objects.\n    _tracer() {\n        return noop.tracer;\n    }\n\n    // By default does nothing\n    _setOperationName(name) {\n    }\n\n    // By default does nothing\n    _setBaggageItem(key, value) {\n    }\n\n    // By default does nothing\n    _getBaggageItem(key) {\n    }\n\n    // By default does nothing\n    //\n    // NOTE: both setTag() and addTags() map to this function. keyValuePairs\n    // will always be an associative array.\n    _addTags(keyValuePairs) {\n    }\n\n    // By default does nothing\n    _log(keyValuePairs, timestamp) {\n    }\n\n    // By default does nothing\n    //\n    // finishTime is expected to be either a number or undefined.\n    _finish(finishTime) {\n    }\n}\n"]}